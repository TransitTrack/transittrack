/* (C)2023 */
package org.transitclock.service;

import com.google.common.base.CaseFormat;
import lombok.extern.slf4j.Slf4j;
import org.hibernate.HibernateException;
import org.hibernate.Session;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.transitclock.core.avl.AvlProcessor;
import org.transitclock.core.avl.time.TemporalMatch;
import org.transitclock.core.VehicleStatus;
import org.transitclock.core.avl.AvlReportProcessor;
import org.transitclock.core.dataCache.PredictionDataCache;
import org.transitclock.core.dataCache.VehicleDataCache;
import org.transitclock.core.dataCache.VehicleStatusManager;
import org.transitclock.domain.hibernate.DataDbLogger;
import org.transitclock.domain.hibernate.HibernateUtils;
import org.transitclock.domain.structs.AvlReport;
import org.transitclock.domain.structs.VehicleEvent;
import org.transitclock.domain.structs.VehicleToBlockConfig;
import org.transitclock.service.contract.CommandsService;
import org.transitclock.service.dto.IpcAvl;
import org.transitclock.service.dto.IpcVehicleComplete;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Collection;
import java.util.Date;

@Slf4j
@Component
public class CommandsServiceImpl implements CommandsService {
    @Autowired
    private PredictionDataCache predictionDataCache;
    @Autowired
    private VehicleDataCache vehicleDataCache;
    @Autowired
    private AvlProcessor avlProcessor;
    @Autowired
    private VehicleStatusManager vehicleStatusManager;
    @Autowired
    private DataDbLogger dataDbLogger;
    @Autowired
    private AvlReportProcessor avlReportProcessor;

    /**
     * Called on server side via RMI when AVL data is to be processed
     *
     * @param avlData AVL data sent to server
     * @return Null if OK, otherwise an error message
     */
    @Override
    public String pushAvl(IpcAvl avlData) {
        // Use AvlExecutor to actually process the data using a thread executor
        AvlReport avlReport = new AvlReport(avlData);
        logger.debug("Processing AVL report {}", avlReport);
        avlReportProcessor.process(avlReport);

        // Return that was successful
        return null;
    }

    /**
     * Called on server side via RMI when AVL data is to be processed
     *
     * @param avlDataCollection AVL data sent to server
     * @return Null if OK, otherwise an error message
     */
    @Override
    public String pushAvl(Collection<IpcAvl> avlDataCollection) {
        for (IpcAvl avlData : avlDataCollection) {
            // Use AvlExecutor to actually process the data using a thread executor
            AvlReport avlReport = new AvlReport(avlData);
            logger.debug("Processing AVL report {}", avlReport);
            avlReportProcessor.process(avlReport);
        }

        // Return that was successful
        return null;
    }

    @Override
    public void setVehicleUnpredictable(String vehicleId) {
        VehicleStatus vehicleStatus = vehicleStatusManager.getStatus(vehicleId);

        // Create a VehicleEvent to record what happened
        AvlReport avlReport = vehicleStatus.getAvlReport();
        TemporalMatch lastMatch = vehicleStatus.getMatch();
        boolean wasPredictable = vehicleStatus.isPredictable();

        String vehicleEvent = "Command called to make vehicleId unpredicable. ";
        String eventDescription = "Command called to make vehicleId unpredicable. ";
        VehicleEvent vehicleEvent1 = new VehicleEvent(
                avlReport,
                lastMatch,
                vehicleEvent,
                eventDescription,
                false, // predictable
                wasPredictable, // becameUnpredictable
                null);// supervisor
        dataDbLogger.add(vehicleEvent1);


        // Update the state of the vehicle
        vehicleStatus.setMatch(null);

        // Remove the predictions that were generated by the vehicle
        predictionDataCache.removePredictions(vehicleStatus);

        // Update VehicleDataCache with the new state for the vehicle
        vehicleDataCache.updateVehicle(vehicleStatus);
    }

    private VehicleStatus getVehicleStateForTrip(String tripId, LocalDateTime _startTripTime) {
        /* The startTripTime parameter should not be null if noSchedule */
        long startTripTime = 0;
        if (_startTripTime != null)
            startTripTime = _startTripTime.atZone(ZoneId.systemDefault()).toEpochSecond() * 1000L;
        /*
         * Get the vehicle associated to the tripId. Is it possible to have more than 1 bus with the
         * same tripId??
         */
        Collection<IpcVehicleComplete> ipcVehicleCompletList =
                vehicleDataCache.getVehiclesIncludingSchedBasedOnes();
        VehicleStatus vehicleStatus = null;
        for (IpcVehicleComplete _ipcVehicle : ipcVehicleCompletList) {

            if (_ipcVehicle.getTripId() != null && _ipcVehicle.getTripId().compareTo(tripId) == 0) {
                VehicleStatus _vehicleStatus = vehicleStatusManager.getStatus(_ipcVehicle.getId());
                boolean noSchedule = _vehicleStatus.getTrip().isNoSchedule();
                if (!noSchedule) {
                    vehicleStatus = _vehicleStatus;
                    break;
                } else if (noSchedule && _ipcVehicle.getTripStartEpochTime() == startTripTime) {
                    vehicleStatus = _vehicleStatus;
                    break;
                }
            }
        }
        return vehicleStatus;
    }

    @Override
    public String cancelTrip(String tripId, LocalDateTime startTripTime) {

        // String vehicleId=	"block_" + blockId + "_schedBasedVehicle";
        VehicleStatus vehicleStatus = this.getVehicleStateForTrip(tripId, startTripTime);
        if (vehicleStatus == null) return "TripId id is not currently available";

        AvlReport avlReport = vehicleStatus.getAvlReport();
        if (avlReport != null) {
            vehicleStatus.setCanceled(true);
            vehicleDataCache.updateVehicle(vehicleStatus);
            avlProcessor.processAvlReport(avlReport);
            return null;
        } else return "vehicle with this trip id does not have avl report";
    }

    @Override
    public String reenableTrip(String tripId, LocalDateTime startTripTime) {

        // String vehicleId=	"block_" + blockId + "_schedBasedVehicle";
        VehicleStatus vehicleStatus = this.getVehicleStateForTrip(tripId, startTripTime);
        if (vehicleStatus == null) return "TripId id is not currently available";
        AvlReport avlReport = vehicleStatus.getAvlReport();
        if (avlReport != null) {
            vehicleStatus.setCanceled(false);
            vehicleDataCache.updateVehicle(vehicleStatus);
            avlProcessor.processAvlReport(avlReport);
            return null;
        } else return "vehicle with this trip id does not have avl report";
    }

    @Override
    public String addVehicleToBlock(
            String vehicleId, String blockId, String tripId, Date assignmentDate, Date validFrom, Date validTo) {
        VehicleToBlockConfig vehicleToBlockConfig = new VehicleToBlockConfig(vehicleId, blockId, tripId, assignmentDate, validFrom, validTo);
        dataDbLogger.add(vehicleToBlockConfig);
        return null;
    }

    @Override
    public String removeVehicleToBlock(long id) {
        try (Session session = HibernateUtils.getSession()) {
           return VehicleToBlockConfig.deleteVehicleToBlockConfig(id, session);
        } catch (Exception ex) {
           logger.warn("Something went wrong when trying to delete a raw from {} table",
                       CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, VehicleToBlockConfig.class.getSimpleName()));
           throw new HibernateException(ex.getMessage());
        }
    }
}
